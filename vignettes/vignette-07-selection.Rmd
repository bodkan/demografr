---
title: Non-neutral _slendr_ simulations
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Non-neutral _slendr_ simulations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
slendr_present <- slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE)

knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.align = "center",
  fig.width = 8,
  fig.height = 5,
  dpi = 80,
  eval = slendr_present
)

devtools::load_all("/home/slendr")
devtools::load_all()

data_path <- here::here("inst/examples/selection_abc.rds")
```

```{r}
library(demografr)
library(slendr)

library(ggplot2)
library(dplyr)
library(tidyr)

library(future)
plan(multisession)

init_env(quiet = TRUE)
```

```{r}
extension_code <- r"(
// Define model constants (to be substituted) all in one place
// (each {{placeholder}} will be replaced by a value passed from R).
// Note that string constant template patterns are surrounded by "quotes"!
initialize() {
    defineConstant("s", {{s}});
    defineConstant("onset_time", {{onset_time}});
    defineConstant("target_pop", "{{target_pop}}");
    defineConstant("origin_pop", "{{origin_pop}}");

    // compose a trajectory file based on given parameters
    defineConstant("traj_file", PATH + "/" +
                                "traj_" + target_pop + "_" + origin_pop + ".tsv");
}
// Because we want to simulate non-neutral evolution, we have to provide a
// custom initialization callback -- slendr will use it to replace its default
// neutral genomic architecture (i.e. the initialize() {...} callback it uses
// by default for neutral simulations). Note that we can refer to slendr's
// constants SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values
// passed through from R via slendr's slim() R function.
initialize() {
    initializeMutationType("m1", 0.5, "f", s);

    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);

    initializeMutationRate(0);
    initializeRecombinationRate(RECOMBINATION_RATE);
}

function (void) add_mutation(void) {
    // sample one target carrier of the new mutation...
    target = sample(population(origin_pop).genomes, 1);
    // ... and add the mutation in the middle of it
    mut = target.addNewDrawnMutation(m1, position = asInteger(SEQUENCE_LENGTH / 2));

    // save the mutation for later reference
    defineGlobal("MUTATION", mut);

    write_log("adding beneficial mutation to population " + target_pop);

    writeFile(traj_file, "time\tfreq_origin\tfreq_target");
}

tick(onset_time) late() {
    // save simulation state in case we need to restart if the mutation is lost
    save_state();

    add_mutation();
}

tick(onset_time):SIMULATION_END late() {
    // the mutation is not segregating and is not fixed either -- we must restart
    if (!MUTATION.isSegregating & !MUTATION.isFixed) {
        write_log("mutation lost -- restarting");

        reset_state();

        add_mutation();
    }

    // compute the frequency of the mutation of interest and save it (if the
    // mutation is missing at this time, save its frequency as NA)
    freq_origin = "NA";
    freq_target = "NA";
    if (population(origin_pop, check = T))
      freq_origin = population(origin_pop).genomes.mutationFrequenciesInGenomes();
    if (population(target_pop, check = T))
      freq_target = population(target_pop).genomes.mutationFrequenciesInGenomes();

    writeFile(traj_file,
              model_time(community.tick) + "\t" +
              freq_origin + "\t" +
              freq_target, append = T);
}
)"

model <- function(s, onset_time, origin_pop, target_pop) {
  extension <- substitute_values(
    extension_code,
    s = s, onset_time = as.integer(onset_time),
    origin_pop = origin_pop, target_pop = target_pop
  )
  
  afr <- population("AFR", time = 90000, N = 3000)
  ooa <- population("OOA", parent = afr, time = 60000, N = 500, remove = 23000)
  ehg <- population("EHG", parent = ooa, time = 28000, N = 1000, remove = 6000)
  eur <- population("EUR", parent = ehg, time = 25000, N = 5000)
  ana <- population("ANA", time = 28000, N = 3000, parent = ooa, remove = 4000)
  yam <- population("YAM", time = 8000, N = 500, parent = ehg, remove = 2500)
  
  gf <- list(
    gene_flow(from = ana, to = yam, rate = 0.4, start = 7900, end = 7800),
    gene_flow(from = ana, to = eur, rate = 0.5, start = 6000, end = 5000),
    gene_flow(from = yam, to = eur, rate = 0.65, start = 4000, end = 3500)
  )
  
  model <- compile_model(
    populations = list(afr, ooa, ehg, eur, ana, yam),
    gene_flow = gf, generation_time = 30,
    extension = extension
  )

  samples <- schedule_sampling(model, time = 0, list(eur, 50))
  
  return(list(model, samples))
}
```

```{r}
devtools::load_all("/home/slendr")

m <- model(s = 0.1, onset_time = 5000, origin_pop = "EUR", target_pop = "EUR")
m
```

```{r}
result <- slim(m[[1]], samples = m[[2]], sequence_length = 1e6, recombination_rate = 1e-8, path = TRUE)
result <- slim(m[[1]], samples = m[[2]], sequence_length = 1e6, recombination_rate = 1e-8, path = TRUE, ts = FALSE)
```

```{r}
priors <- list(
  s ~ runif(0, 0.1),
  onset_time ~ runif(3000, 20000)
)
```

```{r}
data <- simulate_model(
  model, priors,
  sequence_length = 1e6, recombination_rate = 0,
  model_args = list(origin_pop = "EUR", target_pop = "EUR"),
  engine = "msprime",
  format = "files",
  data = list(
    ts = function(path, model) ts_read(file.path(path, "msprime.trees"), model) %>% ts_mutate(1e-8)
  )
)
```

```{r}
data <- simulate_model(
  model, priors,
  sequence_length = 1e6, recombination_rate = 0,
  model_args = list(origin_pop = "EUR", target_pop = "EUR"),
  format = "files",
  data = list(
    ts = function(path, model) file.path(path, "slim.trees") %>% ts_read(model) %>% ts_mutate(1e-8),
    trajectory = function(path) readr::read_tsv(file.path(path, "traj_EUR_EUR.tsv"), show_col_types = FALSE)
  )
)
```

```{r}
functions <- quote(list(trajectory = trajectory))
summarise_data(data, functions = functions)

summarise_data(data, functions = list(trajectory = trajectory))
```


```{r}
grid <- expand_grid(s = seq(0, 0.2, 0.02), onset_time = seq(2000, 20000, by = 2000)) %>% head(3)
grid

data <- simulate_grid(
  model, grid, functions = list(target_trajectory = function(df) df[c("time", "freq_target")],
                                origin_trajectory = function(df) df[c("time", "freq_origin")]),
  format = "files", data = list(df = function(path) readr::read_tsv(file.path(path, "traj_EUR_EUR.tsv"), show_col_types = FALSE)),
  replicates = 5, sequence_length = 1e6, recombination_rate = 1e-8,
  model_args = list(origin_pop = "EUR", target_pop = "EUR")
)
```

```{r}
data %>%
  unnest(target_trajectory) %>%
  ggplot(aes(time, freq_target)) +
  geom_line(aes(color = factor(s), group = rep)) +
  ylim(c(0, 1)) +
  facet_wrap(~ onset_time)
```


