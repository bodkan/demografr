---
title: "A basic ABC analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A basic ABC analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
slendr_present <- slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE)

knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.align = "center",
  fig.width = 8,
  fig.height = 5,
  dpi = 80,
  eval = slendr_present
)

data_path <- here::here("inst/examples/basics_abc.rds")
```

```{r, echo=FALSE, message=FALSE}
library(slendr)

init_env()

SEED <- 42
set.seed(SEED)
```

```{r, eval=!file.exists(data_path), echo=FALSE, message=FALSE}
# this simulates the entire example data set (also used in the ProbGen23 poster)
popA <- population("popA", time = 1, N = 2000)
popB <- population("popB", time = 2000, N = 800, parent = popA)
popC <- population("popC", time = 6000, N = 9000, parent = popB)
popD <- population("popD", time = 8000, N = 4000, parent = popC)

gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = 0.1)

example_model <- compile_model(
  populations = list(popA, popB, popC, popD), gene_flow = gf,
  generation_time = 1,
  simulation_length = 10000
)

ts <- msprime(example_model, sequence_length = 100e6, recombination_rate = 1e-8, random_seed = SEED) %>%
  ts_mutate(1e-8, random_seed = SEED)

samples <- extract_names(ts, split = "pop")

observed_diversity <- ts_diversity(ts, sample_sets = samples)
observed_divergence <- ts_divergence(ts, sample_sets = samples)
observed_f4 <- ts_f4(ts,
                     W = list(popA = samples$popA),
                     X = list(popB = samples$popB),
                     Y = list(popC = samples$popC),
                     Z = list(popD = samples$popD))

write.table(observed_diversity, file = here::here("inst/examples/observed_diversity.tsv"),
            sep = "\t", row.names = FALSE, quote = FALSE)
write.table(observed_divergence, file = here::here("inst/examples/observed_divergence.tsv"),
            sep = "\t", row.names = FALSE, quote = FALSE)
write.table(observed_f4, file = here::here("inst/examples/observed_f4.tsv"),
            sep = "\t", row.names = FALSE, quote = FALSE)
```

⚠️⚠️⚠️

**Note:** The _demografr_ R package is still under active development. As a result, its documentation is in a draft stage at best. Apologies for typos, inconsistencies, and other issues.

⚠️⚠️⚠️

This vignette contains an expanded version of the basic ABC inference example from the [homepage](https://bodkan.net/demografr/) of _demografr_. It walks through the process of setting up a _demografr_ ABC pipeline step by step.

## Introduction

Imagine that we sequenced genomes of individuals from populations "popA", "popB", "popC", and "popD".

Let's also assume that we know that the three populations are phylogenetically related in the following way but we don't know anything else (i.e., we have no idea about the values of $N_e$, split times, or gene-flow rates):

```{r ape_tree, echo=FALSE, fig.width=5, fig.height=3.5}
par(mar = c(0, 0, 0, 0))
tree <- ape::read.tree(text="(popA,(popB,(popC,popD)));")
plot(tree)
arrows(2.5, 2, 2.5, 3, col="blue")
```

After sequencing the genomes of individuals from these populations, we computed nucleotide diversity in these populations as well as their pairwise genetic divergence and a one $f_4$ statistic, observing the following values of these summary statistics (which we saved in standard R data frames&mdash;perhaps saved by software we used for computing these from empirical sequence data):

1. Nucleotide diversity in each population:

```{r}
observed_diversity <- read.table(system.file("examples/observed_diversity.tsv", package = "demografr"), header = TRUE)

observed_diversity
```

2. Pairwise divergence d_X_Y between populations X and Y:

```{r}
observed_divergence <- read.table(system.file("examples/observed_divergence.tsv", package = "demografr"), header = TRUE)

observed_divergence
```

3. Value of the following $f_4$-statistic:

```{r}
observed_f4  <- read.table(system.file("examples/observed_f4.tsv", package = "demografr"), header = TRUE)

observed_f4
```

**Now let's develop a simple ABC pipeline which will infer the posterior distributions of two sets of parameters we are interested in: $N_e$ of each population lineage, as well as split times between our populations of interest.**

## Developing an ABC pipeline

Let's begin by loading _demografr_ together with the R package [_slendr_](https://www.slendr.net/) on which _demografr_ relies on for building and simulating demographic models.

```{r, message=FALSE}
library(demografr)
library(slendr)

# we also have to activate slendr's internal environment for tree sequences
# simulation and analysis
init_env()

# setup parallelization across all CPUs
library(future)
plan(multicore, workers = availableCores())

library(ggplot2)
```

For the purpose of the ABC analysis below, we will bind all statistics in an R list, naming them appropriately. The names of each statistic (here "diversity" and "divergence") have meaning and are quite important for later steps:

```{r}
observed <- list(
  diversity  = observed_diversity,
  divergence = observed_divergence,
  f4         = observed_f4
)
```

### 1. Setting up a "scaffold" model

The first step in a _demografr_ ABC analysis is setting up a "scaffold" model&mdash;a _slendr_ function which will return a compiled _slendr_ model as its output, and which will accept the model parameters in form of normal R function arguments. In our simple examples, we will define the following function:

```{r}
model <- function(Ne_A, Ne_B, Ne_C, Ne_D, T_AB, T_BC, T_CD, gf_BC = 0.5) {
  popA <- population("popA", time = 1,    N = Ne_A)
  popB <- population("popB", time = T_AB, N = Ne_B, parent = popA)
  popC <- population("popC", time = T_BC, N = Ne_C, parent = popB)
  popD <- population("popD", time = T_CD, N = Ne_D[1], parent = popC)

  gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = gf_BC)

  model <- compile_model(
    populations = list(popA, popB, popC, popD), gene_flow = gf,
    generation_time = 1, simulation_length = 10000,
    direction = "forward", serialize = FALSE
  )

  samples <- schedule_sampling(
    model, times = 10000,
    list(popA, 2), list(popB, 2), list(popC, 2), list(popD, 2),
    strict = TRUE
  )

  # a return statement is mandatory!
  # if a sampling schedule is not generated, use return(model)
  return(list(model, samples))
}
```

### 2. Setting up priors

We are interested in estimating the $N_e$ of all populations and their split times. _demografr_ makes this very easy using a familiar symbolic formula syntax in R:

```{r}
priors <- list(
  Ne_A  ~ runif(1, 10000),
  Ne_B  ~ runif(1, 10000),
  Ne_C  ~ runif(1, 10000),
  Ne_D  ~ runif(1, 10000),

  T_AB  ~ runif(1, 10000),
  T_BC  ~ runif(1, 10000),
  T_CD  ~ runif(1, 10000),

  gf_BC ~ runif(0, 1)
)
```

In an ABC simulation step below, the formulas are used to draw the values of each parameter from specified distributions (in this case, all uniform distributions across a wide range of parameter values).

**For more detail into how _demografr_'s prior sampling formulas work (and why), take a look [here](vignette-02-priors.html).

### 3. Defining summary statistics

Each run of a _demografr_ ABC simulation internally produces a tree sequence as an output. Because tree sequence represents an efficient, succint representation of the complete genealogical history of a set of samples, it is possible to compute population genetic statistics directly on the tree sequence without having to first save each simulation output to disk for computation in different software. Thanks to _slendr_'s library of [tree-sequence functions](https://www.slendr.net/reference/index.html#tree-sequence-statistics) serving as an R interface to the [_tskit_ module](https://tskit.dev/tskit/docs/stable/stats.html), you can specify summary statistics to be computed for ABC using plain and simple R code.

In our example, because we computed nucleotide diversity and pairwise divergence in the individuals sequenced from populations "p1", "p2", and "p3", we will define the following functions. Crucially, when run on a tree-sequence object, they will produce an output data frame in the format analogous to the empirical statistics shown in data frames `diversity` and `divergence` above:

```{r}
compute_diversity <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_diversity(ts, sample_sets = samples)
}
compute_divergence <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_divergence(ts, sample_sets = samples)
}
compute_f4 <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_f4(ts,
        W = list(popA = samples$popA),
        X = list(popB = samples$popB),
        Y = list(popC = samples$popC),
        Z = list(popD = samples$popD))
}

functions <- list(
  diversity  = compute_diversity,
  divergence = compute_divergence,
  f4         = compute_f4
)
```

Crucially, the outputs of these summary functions _must_ match the format of the observed summary statistics (i.e., the data frames produced must have the same format). This minor inconvenience during ABC setup saves us the headache of having to match values of statistics between observed and simulated data during ABC inference itself.

### 4. ABC simulations

Having defined the scaffold model, a set of priors for our parameters of interest ($N_e$ and split times), as well as two summary statistic functions, we can plug all this information into the function `simulate_abc()`.

Before we run a potentially computationally costly simulations, it is a good idea to validate the ABC components we have so far assembled using the function `validate_abc()`:

```{r}
validate_abc(model, priors, functions, observed)
```

Having verified that all model components are set up correctly, we can proceed to the ABC simulations themselves, using _demografr_'s function `simulate_abc()`:

```{r, echo=FALSE, eval=TRUE}
tstart <- Sys.time()
```

```{r, eval=!file.exists(data_path)}
data <- simulate_abc(
  model, priors, functions, observed, iterations = 10000,
  sequence_length = 10e6, recombination_rate = 1e-8, mutation_rate = 1e-8
)
```

```{r, echo=FALSE, eval=TRUE}
tend <- Sys.time()
tdelta <- as.numeric(difftime(tend, tstart, units = "secs"))
ncores <- future::availableCores()
```

```{r, echo=FALSE, eval=!file.exists(data_path)}
saveRDS(tdelta, here::here("inst/examples/basics_tdelta.rds"))
saveRDS(ncores, here::here("inst/examples/basics_ncores.rds"))
```

```{r, echo=FALSE, eval=file.exists(data_path)}
tdelta <- readRDS(here::here("inst/examples/basics_tdelta.rds"))
ncores <- readRDS(here::here("inst/examples/basics_ncores.rds"))
```

```{r, echo=FALSE, eval=TRUE}
hours <- floor(tdelta / 3600)
minutes <- floor((tdelta - hours * 3600) / 60)
seconds <- round(tdelta - hours * 3600 - minutes * 60)
```

**The total runtime for the ABC simulations was `r paste(hours, "hours", minutes, "minutes", seconds, "seconds")` parallelized across `r ncores` CPUs.**

At this point we have generated summary statistics for simulations of models using parameters drawn from our priors. In the next step, we can finally do inference of our parameters.

### 5. ABC inference

Having all the information about observed and simulated data bound in a single R object `data`, we can finally perform the ABC inference. _demografr_ includes a convenient function `perform_abc()` which reformats the simulated and observed data in a format required by the R package [_abc_](https://cran.r-project.org/package=abc) and internally calls its function `abc()`.

Note that `perform_abc` is just convenience wrapper around the `abc()` function in the package _abc_`, saving us a little work juggling the necessary matrices manually. As such, all parameters of the function `abc()` can be provided to `perform_abc()`, which will then pass them on appropriately.

```{r, eval=file.exists(data_path), echo=FALSE}
abc <- readRDS(data_path)
```

```{r, eval=!file.exists(data_path), echo=FALSE}
abc <- perform_abc(data, engine = "abc", tol = 0.03, method = "neuralnet", seed = 42)
```

```{r, eval=!file.exists(data_path), echo=FALSE}
saveRDS(abc, data_path)
```

### 6. Posterior analysis

#### Extracting posterior summary tables

Now that we have the ABC output object ready, we can get a data frame with summary statistics of the posterior distributions of our parameters. For instance, we can easily read the maximum a posteriori probability (MAP) of the parameters in the row labelled "Weighted Mode:":

```{r}
extract_summary(abc)
```

Because large tables can get a little hard to read, it is possible to subset to only a specific _type_ of parameter:

```{r}
extract_summary(abc, param = "Ne")
```

```{r}
extract_summary(abc, param = "T")
```

Alternatively, we can also extract the posterior summary for a single parameter like this:

```{r}
extract_summary(abc, param = "Ne_D")
```

#### Visualizing posterior distributions of parameters

Because a chart is always more informative than a table, we can easily get a visualization of our posteriors using the function `plot_posterior()`:

```{r, posterior_Ne, fig.width=8, fig.height=5}
plot_posterior(abc, param = "Ne") + coord_cartesian(xlim = c(0, 10000))
```

Excellent! It looks like we got really nice and informative posterior distributions of $N_e$ values!

In contrast, it looks like the posterior distributions for split times are not as informative compared to the priors that we specified:

```{r, posterior_Tsplit, fig.width=8, fig.height=5}
plot_posterior(abc, param = "T") + coord_cartesian(xlim = c(0, 10000))
```

Because the internals of _demografr_ ABC objects are represented by standard objects created by the _abc_ package, we have many of the standard diagnostics functions of the _abc_ R package at our disposal. For instance, we can use the standard function `plot()` to verify that the posterior (red line) for one of the split times matches the prior (dashed line), suggesting that the data we provided (nucleotide diversity and pairwise divergence) are not sufficient statistics to capture enough information about population divergences.

```{r, diagnostic_Tsplit, fig.width=10, fig.height=7}
plot(abc, param = "T_BC")
```

In contrast, we can see that there most definitely is sufficient information encoded in the summary statistics to tell us quite a bit about the $N_e$ of our populations:

```{r, diagnostic_Ne, fig.width=10, fig.height=7}
plot(abc, param = "Ne_B")
```

```{r, diagnostic_hist_Ne, fig.width=10, fig.height=7}
hist(abc, param = "gf")
```