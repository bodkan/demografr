---
title: "Genetic algorithm optimization"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Genetic algorithm optimization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
slendr_present <- slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE)

knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.align = "center",
  fig.width = 8,
  fig.height = 5,
  dpi = 80,
  eval = slendr_present
)

result_path <- here::here("inst/examples/ga_result.rds")
time_path <- here::here("inst/examples/ga_time.rds")

devtools::load_all()
```

```{r, echo=FALSE, message=FALSE}
library(demografr)
library(slendr)
init_env()

library(GA)

SEED <- 42
set.seed(SEED)
```

Load empirical summary statistics computed from the observed data:

```{r}
observed_diversity <- read.table(system.file("examples/observed_diversity.tsv", package = "demografr"), header = TRUE)
observed_divergence <- read.table(system.file("examples/observed_divergence.tsv", package = "demografr"), header = TRUE)
observed_f4  <- read.table(system.file("examples/observed_f4.tsv", package = "demografr"), header = TRUE)

observed <- list(
  diversity  = observed_diversity,
  divergence = observed_divergence,
  f4         = observed_f4
)
```

Specify the scaffold model function (each function argument corresponds to one parameter to be inferred):

```{r}
model <- function(Ne_A, Ne_B, Ne_C, Ne_D, T_AB, T_BC, T_CD, gf_BC) {
  popA <- population("popA", time = 1,    N = Ne_A)
  popB <- population("popB", time = T_AB, N = Ne_B, parent = popA)
  popC <- population("popC", time = T_BC, N = Ne_C, parent = popB)
  popD <- population("popD", time = T_CD, N = Ne_D, parent = popC)

  gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = gf_BC)

  model <- compile_model(
    populations = list(popA, popB, popC, popD), gene_flow = gf,
    generation_time = 1, simulation_length = 10000,
    direction = "forward", serialize = FALSE
  )

  samples <- schedule_sampling(
    model, times = 10000,
    list(popA, 25), list(popB, 25), list(popC, 25), list(popD, 25),
    strict = TRUE
  )

  return(list(model, samples))
}
```

Specify tree-sequence summary statistics (one function per one observed statistic, as defined above):

```{r}
compute_diversity <- function(ts) {
  samples <- ts_names(ts, split = "pop")
  ts_diversity(ts, sample_sets = samples)
}
compute_divergence <- function(ts) {
  samples <- ts_names(ts, split = "pop")
  ts_divergence(ts, sample_sets = samples)
}
compute_f4 <- function(ts) {
  samples <- ts_names(ts, split = "pop")
  A <- samples["popA"]; B <- samples["popB"]
  C <- samples["popC"]; D <- samples["popD"]
  rbind(
    ts_f4(ts, A, B, C, D),
    ts_f4(ts, A, C, B, D),
    ts_f4(ts, A, D, B, C)
  )
}

functions <- list(
  diversity  = compute_diversity,
  divergence = compute_divergence,
  f4         = compute_f4
)
```

```{r}
# par <- list(100, 100, 100, 100, 2, 3000, 5000, 0.5)
# names(par) <- formals(model) %>% names()

# optim_fn(par, model, observed)

# res <- optim(par = par, fn = optim_fn, model = model, observed = observed,
#              method = "SANN",
#              lower = list(Ne_A = 1,
#                           Ne_B = 1,
#                           Ne_C = 1,
#                           Ne_D = 1,
#                           T_AB = 1,
#                           T_BC = 1,
#                           T_CD = 1,
#                           gf_BC = 0),
#              upper = list(Ne_A = 10000,
#                           Ne_B = 10000,
#                           Ne_C = 10000,
#                           Ne_D = 10000,
#                           T_AB = 10000,
#                           T_BC = 10000,
#                           T_CD = 10000,
#                           gf_BC = 1))

start <- Sys.time()
result <- ga(type = "real-valued",
             fitness = optim_fn,
             model = model,
             functions = functions,
             observed = observed,
             sequence_length = 1e6,
             recombination_rate = 1e-8,
             mutation_rate = 1e-8,
             engine = NULL, model_args = NULL, engine_args = NULL,
             model_name = "model",
             param_names = c("Ne_A", "Ne_B", "Ne_C", "Ne_D", "T_AB", "T_BC", "T_CD", "gf_BC"),
             lower = c(1, 1, 1, 1, 1, 1, 1, 0),
             upper = c(10000, 10000, 10000, 10000, 10000, 10000, 10000, 1),
             popSize = 50,
             maxiter = 500,
             parallel = TRUE)
end <- Sys.time()
time <- end - start
```

```{r}
saveRDS(result, result_path)
saveRDS(time, time_path)
```

```{r}
result <- readRDS(result_path)
time <- readRDS(time_path)
```

```{r}
plot(result)
```

Checking the fitness of the best solution:

```{r}
colnames(result@solution) <- names(formals(model))
result@solution
```

```{r}
result@fitnessValue

fit_par <- as.list(result@solution)
names(fit_par) <- colnames(result@solution)

optim_fn(fit_par, model, functions, observed)
```

Fitness value for the true parameter vector:

```{r}
par <- list(Ne_A = 2000, Ne_B = 800, Ne_C = 9000, Ne_D = 4000, T_AB = 2000, T_BC = 6000, T_CD = 8000, gf = 0.1)

optim_fn(par, model, functions, observed)
```

```{r}
bounds <- list(
  Ne...  ~ between(1, 10000),
  T...   ~ between(1, 10000),
  gf_BC  ~ between(0, 1)
)

result <- run_ga(model, functions, observed, bounds, iterations = 10,
                 sequence_length = 10e6, recombination_rate = 1e-8, mutation_rate = 1e-8,
                 parallel = TRUE)
```

