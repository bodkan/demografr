---
title: "Downstream analyses, model selection, troubleshooting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Downstream analyses, model selection, troubleshooting"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
slendr_present <- slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE)

knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.align = "center",
  fig.width = 8,
  fig.height = 5,
  dpi = 80,
  eval = FALSE #slendr_present
)

bottleneck_path <- here::here("inst/examples/downstream_abc_bottle.rds")
const_path <- here::here("inst/examples/downstream_abc_const.rds")
exp_path <- here::here("inst/examples/downstream_abc_exp.rds")

devtools::load_all()
```

```{r}
library(demografr)
library(slendr)
init_env()

SEED <- 42
set.seed(SEED)
```

Let's return to our [first](vignette-01-basics.html) example. However, this time, imagine that we don't really know whether which of the three following phylogenetic relationships is the one that captures the features of our data best, perhaps with different sources of evidence being consistent with one of them (as always, this is purely a toy example). In other words, we want to perform *model selection*.

```{r ape_tree_modelX, echo=FALSE, fig.width=5, fig.height=3.5}
par(mar = c(0, 0, 2, 0), mfrow = c(3, 1))
tree <- ape::read.tree(text="(popA,(popB,(popC,popD)));")
plot(tree, main = "model X")
arrows(2.5, 2, 2.5, 3, col="blue")

tree <- ape::read.tree(text="((popA,popB),(popC,popD));")
plot(tree, main = "model Y")
arrows(2.5, 2, 2.5, 3, col="blue")

tree <- ape::read.tree(text="(((popA,popB),popC),popD);")
plot(tree, main = "model Z")
arrows(2.5, 2, 2.5, 3, col="blue")
```

For completeness, here is again our computed observed data:

1. Nucleotide diversity in each population:

```{r}
observed_diversity <- read.table(system.file("examples/observed_diversity.tsv", package = "demografr"), header = TRUE)

observed_diversity
```

2. Pairwise divergence d_X_Y between populations X and Y:

```{r}
observed_divergence <- read.table(system.file("examples/observed_divergence.tsv", package = "demografr"), header = TRUE)

observed_divergence
```

3. Value of the following $f_4$-statistic:

```{r}
observed_f4  <- read.table(system.file("examples/observed_f4.tsv", package = "demografr"), header = TRUE)

observed_f4
```

We will again bind them into a list:

```{r}
observed <- list(diversity  = observed_diversity, divergence = observed_divergence, f4 = observed_f4)
```


### Three competing models

First, in order to perform model selection, we need the models themselves. In this example, we have to options to do this.

**First**, we can define three separate functions, each of them encoding the three phylogenetic relationships:

```{r}
modelX <- function(Ne_A, Ne_B, Ne_C, Ne_D, T_1, T_2, T_3, gf) {
  popA <- population("popA", time = 1,   N = Ne_A)
  popB <- population("popB", time = T_1, N = Ne_B, parent = popA)
  popC <- population("popC", time = T_2, N = Ne_C, parent = popB)
  popD <- population("popD", time = T_3, N = Ne_D, parent = popC)

  gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = gf)

  model <- compile_model(
    populations = list(popA, popB, popC, popD), gene_flow = gf,
    generation_time = 1, simulation_length = 10000,
    direction = "forward"
  )

  return(model)
}

modelY <- function(Ne_A, Ne_B, Ne_C, Ne_D, T_1, T_2, T_3, gf) {
  popA <- population("popA", time = 1,   N = Ne_A)
  popB <- population("popB", time = T_1, N = Ne_B, parent = popA)
  popC <- population("popC", time = T_2, N = Ne_C, parent = popA)
  popD <- population("popD", time = T_3, N = Ne_D, parent = popC)

  gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = gf)

  model <- compile_model(
    populations = list(popA, popB, popC, popD), gene_flow = gf,
    generation_time = 1, simulation_length = 10000,
    direction = "forward"
  )

  return(model)
}

modelZ <- function(Ne_A, Ne_B, Ne_C, Ne_D, T_1, T_2, T_3, gf) {
  popA <- population("popA", time = 1,   N = Ne_A)
  popB <- population("popB", time = T_1, N = Ne_B, parent = popA)
  popC <- population("popC", time = T_2, N = Ne_C, parent = popA)
  popD <- population("popD", time = T_3, N = Ne_D, parent = popA)

  gf <- gene_flow(from = popB, to = popC, start = 9000, end = 9301, rate = gf)

  model <- compile_model(
    populations = list(popA, popB, popC, popD), gene_flow = gf,
    generation_time = 1, simulation_length = 10000,
    direction = "forward"
  )

  return(model)
}
```


```{r, eval=FALSE}
modelX(1, 1, 1, 1, 2000, 6000, 8000, 0.5) %>% plot_model(order = c("popA", "popB", "popC", "popD"))
modelY(1, 1, 1, 1, 2000, 6000, 8000, 0.5) %>% plot_model(order = c("popA", "popB", "popC", "popD"))
modelZ(1, 1, 1, 1, 2000, 6000, 8000, 0.5) %>% plot_model(order = c("popA", "popB", "popC", "popD"))
```

Now, let's [specify priors](vignette-02-priors.html) using _demografr_'s [templating syntax](vignette-02-priors.html#prior-parameter-templates) , as well as put together a list of tree-sequence summary functions and observed summary statistics:

```{r}
priors <- list(
  Ne... ~ runif(100, 10000),

  T_1   ~ runif(1,    4000),
  T_2   ~ runif(3000, 9000),
  T_3   ~ runif(5000, 10000),

  gf    ~ runif(0, 1)
)

compute_diversity <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_diversity(ts, sample_sets = samples)
}
compute_divergence <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_divergence(ts, sample_sets = samples)
}
compute_f4 <- function(ts) {
  samples <- extract_names(ts, split = "pop")
  ts_f4(ts,
        W = list(popA = samples$popA),
        X = list(popB = samples$popB),
        Y = list(popC = samples$popC),
        Z = list(popD = samples$popD))
}

functions <- list(diversity = compute_diversity, divergence = compute_divergence, f4 = compute_f4)

observed <- list(diversity = observed_diversity, divergence = observed_divergence, f4 = observed_f4)
```

```{r, eval=FALSE}
validate_abc(modelX, priors, functions, observed)
validate_abc(modelY, priors, functions, observed)
validate_abc(modelZ, priors, functions, observed)
```


```{r, eval=FALSE}
tsX <- simulate_ts(modelX, priors)
tsY <- simulate_ts(modelY, priors)
tsZ <- simulate_ts(modelZ, priors)
```


With that out of the way, we can proceed with generating simulated data for inference using all three models. What we'll do is perform three runs and save them into appropriately named variables `dataX`, `dataY`, and `dataZ`:

```{r}
library(future)
plan(multicore, workers = 10)
```

```{r}
dataX <- simulate_abc(modelX, priors, functions, observed, iterations = 1000,
                      sequence_length = 1e6, recombination_rate = 1e-8, mutation_rate = 1e-8)
```

```{r}
dataY <- simulate_abc(modelY, priors, functions, observed, iterations = 1000,
                      sequence_length = 1e6, recombination_rate = 1e-8, mutation_rate = 1e-8)
```

```{r}
dataZ <- simulate_abc(modelZ, priors, functions, observed, iterations = 1000,
                      sequence_length = 1e6, recombination_rate = 1e-8, mutation_rate = 1e-8)
```

```{r}
saveRDS(dataX, "dataX.rds")
saveRDS(dataY, "dataY.rds")
saveRDS(dataZ, "dataZ.rds")
```

```{r}
dataX <- readRDS("dataX.rds")
dataY <- readRDS("dataY.rds")
dataZ <- readRDS("dataZ.rds")
```

```{r}
abcX <- perform_abc(dataX, engine = "abc", tol = 0.05, method = "neuralnet")
abcY <- perform_abc(dataY, engine = "abc", tol = 0.05, method = "neuralnet")
abcZ <- perform_abc(dataZ, engine = "abc", tol = 0.05, method = "neuralnet")
```

## Cross-validation

Before doing model selection, it's important to perform cross-validation which you can do using _demografr_'s thin convenience interface wrapper `perform_cv()` built around _abc_'s own function `cv4postpr()`. We will not go into too much detail, as this function simply calls `cv4postpr()` under the hood, passing to it all specified function arguments. For more details, read section "Model selection" in the [vignette](https://cran.r-project.org/package=abc/vignettes/abcvignette.pdf) of the _abc_ R package.

The one difference between the two functions is that `perform_cv()` removes the need to prepare character indices and bind

```{r}
models <- list(modelX = abcX, modelY = abcY, modelZ = abcZ)

cv_result <- perform_cv(models, nval = 50, tol = 0.01, method = "rejection"); summary(cv_result)

cv_result
```
