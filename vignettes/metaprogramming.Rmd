---
title: Cool metaprogramming tricks in R
# output: rmarkdown::html_vignette
output:
  md_document:
    variant: gfm
vignette: >
  %\VignetteIndexEntry{Cool metaprogramming tricks in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 5,
  fig.height = 5,
  dpi = 100
)

devtools::load_all()
```

# Cool metaprogramming tricks in R

How can we let the user define probabilistic statements in R and have the code be as close as possible to normal mathematical notation?

$N_e \sim \mathcal{U}(1000, 10000)$

$\textrm{geneflow} \sim \mathcal{U}(0, 1)$

$T_{\textrm{split}}^i \sim \mathcal{N}(10, 10000)$ for $i \isin \{1, 2, ..., 10\}$

## One trivial option

Something like is used by EasyABC R package:

```{r, eval=FALSE}
list(
  c("Ne", "runif", 1000, 1000),
  c("geneflow", "runif", 0, 1),
  # (not sure how would one create a vector like T_i)
)
```

## Fancier metaprogramming solution

Despite being a _"stupid calculator language"_ (quote by Graham), R is a very powerful functional programming language with advanced metaprogramming options.

> Metaprogramming is a **programming technique in which computer programs have the ability to treat other programs as their data**. It means that a program can be designed to read, generate, analyze or transform other programs, and even modify itself while running.

You might be familiar with the syntax for fitting linear models in R:

```{r, eval=FALSE}
lm(cyl ~ mpg, data = mtcars)
```

The `~` operator creates a so-called "formula object", which captures the expression provided by the user, and can then be manipulated or interpreted by the function that the formula is passed to.

## How to use this for the problem above?

We have functions such as `runif`, `rnorm`, etc., which generate a number from a distribution:

```{r}
runif(n = 1, min = 1000, max = 10000)
```

We can also do this in R, "for free", without doing anything else.

```{r}
prior <- Ne ~ runif(1000, 10000)

prior
```

**This expression is not evaluated! Formula is simply an object carrying a bit of syntax.**

This is important, because the `runif(1000, 10000)` on the right is not a valid R code.

**This is called "lazy evaluation".** R does not evaluate something at the time unless it's "needed" at that time.

## Metaprogramming in R

Metaprogramming is often magic requiring lots of complicated tools, but to do very basic metaprogramming in R is very simple.

How can we "manipulate" code and give it our own meaning?

```{r}
prior
```

When given a formula, the R function `as.list` parses the language expression into smallest possible "atomic pieces":

```{r}
as.list(prior)
```

This is called an **Abstract Syntax Tree** in programming language design.

Note that this works generally for any language expression (even those that are much deeper):

```{r, eval=FALSE}
(a + b) * (c - d / e)
```

But for expressions like the above it is easier to use a proper metaprogramming tool:

```{r}
lobstr::ast((a + b) * (c - d / e))
```

## Back to _demografr_

Coming back to our "prior sampling statement" example:

```{r}
prior
```

which we can parse like this:

```{r}
as.list(prior)
```

_demografr_ parses each such prior sampling statement, and automatically converts the "invalid" expression:

```{r, eval=FALSE}
Ne ~ runif(1000, 10000)
```

into a proper R statement

```{r, eval=FALSE}
runif(n = 1, min = 1000, max = 10000)
```

which is then used during the ABC simulation process.

### `sample_prior()` function

This is implemented by an (internal) _demografr_ function `sample_prior`:

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

## Sampling random vectors

To provide support for random vectors, _demografr_ uses a similar metaprogramming trick as above:

Imagine this syntax for vectorized statements:

```{r}
prior <- T_split[10] ~ runif(10, 10000)
```

```{r}
as.list(prior)
```

Note that this expression is one layer deeper than would be with a plain `T_split ~ runif(10, 10000)`.

This means that for "vector variables" of _demografr_, we need to take care of the nesting:

```{r}
variable <- as.list(prior)[[2]]
variable
```

```{r}
as.list(variable)
```

### In _demografr_ then...

```{r}
sample_prior(T_split[10] ~ runif(10, 10000))
```

## A list of all priors

```{r}
priors <- list(
  Ne          ~ runif(1000, 1000),
  geneflow    ~ runif(0, 1),
  T_split[10] ~ runif(10, 1000)
)
```

In each ABC replicate simulation, _demografr_ then effectively performs this:

```{r}
lapply(priors, sample_prior)
```

**But this is something the user never has to do or care about**, it is done automatically and internally when they call:

```{r, eval=FALSE}
data <- simulate_abc(model, <priors>, functions, observed, ...)
```

## Custom functions

The above also allows custom-defined prior distribution functions.

Imagine this function simulating a loaded casino die:

```{r}
casino_d6 <- function(n = 1) {
  outcomes      <- c(1, 2, 3, 4, 5, 6)
  probabilities <- c(1, 1, 1, 1, 1, 3)
  weights       <- probabilities / sum(probabilities)

  sample(outcomes, size = n, prob = probabilities, replace = TRUE)
}
```

```{r}
prior <- rolls[100] ~ casino_d6()

samples <- sample_prior(prior)
samples
```

```{r}
table(samples$value)
```