---
title: Cool metaprogramming tricks in R
# output: rmarkdown::html_vignette
output:
  md_document:
    variant: gfm
vignette: >
  %\VignetteIndexEntry{Cool metaprogramming tricks in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 5,
  fig.height = 5,
  dpi = 100
)

devtools::load_all()
```

How can we let the user define probabilistic statements in R and have the code be as close as possible to normal mathematical notation?

I.e., things like:

$$N_e \sim Unif(1000, 10000)$$

$$\textrm{geneflow} \sim Unif(0, 1)$$

$$T_{\textrm{split}}^i \sim Norm(10, 10000), \textrm{for } i \in \{1, 2, ..., 10\}$$

## One trivial option

Something like this is used by EasyABC R package:

```{r, eval=FALSE}
list(
  list("Ne", "runif", 1000, 10000),
  list("geneflow", "runif", 0, 1),
  # (not sure how would one create a vector like T_i)
)
```

In Python, you might create some objects like:

```{python, eval=FALSE}
import tensorflow_probability as tfp

# define random variables
Ne = tfp.distributions.Uniform(low=1000., high=10000.)
geneflow = tfp.distributions.Uniform(low=0., high=1.)
T_split = tfp.distributions.Uniform(low=10., high=10000.)

# sample from the distributions
Ne_sample = Ne.sample()
geneflow_sample = geneflow.sample()
T_split_sample = T_split.sample(10)
```

**Can we do this more "elegantly" with less code and closer to actual mathematical notation?**

## Fancier metaprogramming solution

Despite being _"a stupid calculator language"_ (quote by Graham), R is a very powerful functional programming language with advanced metaprogramming options.

> Metaprogramming is a **programming technique in which computer programs have the ability to treat other programs as their data**. It means that a program can be designed to read, generate, analyze or transform other programs, and even modify itself while running.
>
> In other words, **metaprogramming is when code is writing other code.**

You might be familiar with the syntax for fitting linear models in R:

```{r}
head(mtcars)
```

```{r}
lm(cyl ~ mpg, data = mtcars)
```

The **`~` operator creates a so-called "formula object"**, which captures the expression provided by the user, and can then be manipulated or interpreted by the function that the formula is passed to.

## How to use this for the problem above?

Imagine then that we want to write an R interface for doing something like this:

$$N_e \sim Unif(1000, 10000).$$

Obviously, we have functions such as `runif`, `rnorm`, etc., which generate a number from a distribution:

```{r}
runif(n = 1, min = 1000, max = 10000)
```

We can also do this in R, "for free", without doing anything else.

```{r}
prior <- Ne ~ runif(1000, 10000)

prior
```

**This expression is not evaluated! Formula is simply an object carrying a bit of syntax.**

This is important, because the `runif(1000, 10000)` on the right is not a valid R code.

**This is called "lazy evaluation".** R does not evaluate something at the time unless it's "needed" at that time. The opposite to this is "eager evaluation" done by something like Python or C.

## Metaprogramming in R

Metaprogramming is often magic requiring lots of complicated tools, but to do very basic metaprogramming in R is very simple.

How can we "manipulate" code and give it our own meaning?

```{r}
prior
```

When given a formula, the R function **`as.list` parses the language expression into smallest possible "atomic pieces"**:

```{r}
as.list(prior)
```

This is called an **Abstract Syntax Tree** in programming language design.

Note that this works generally for any language expression (even those that are much deeper):

```{r, eval=FALSE}
(a + b) * (c - d / e)
```

But for expressions like the above it is easier to use a proper metaprogramming tool:

```{r}
lobstr::ast((a + b) * (c - d / e))
```

## Back to _demografr_

Coming back to our "prior sampling statement" example:

```{r}
prior
```

which we can parse like this:

```{r}
as.list(prior)
```

And which we hope to interpret in a way that's compatible with something like $N_e \sim Unif(1000, 10000)$.

_demografr_ parses each such prior sampling statement, and automatically converts the "invalid" expression:

```{r, eval=FALSE}
Ne ~ runif(1000, 10000)
```

into a proper R statement

```{r, eval=FALSE}
runif(n = 1, min = 1000, max = 10000)
```

which is then used during the ABC simulation process.

### `sample_prior()` function

This is implemented by an (internal) _demografr_ function `sample_prior`:

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

```{r}
sample_prior(Ne ~ runif(1000, 10000))
```

## Sampling random vectors

To provide support for random vectors, _demografr_ uses a similar metaprogramming trick as above.

Imagine this syntax for vectorized statements (the `T_split[10]` is my made up syntax, not R syntax!):

```{r}
prior <- T_split[10] ~ runif(10, 10000)
```

```{r}
as.list(prior)
```

Note that this expression is one layer "deeper" than would be with a plain `T_split ~ runif(10, 10000)`.

This means that for "vector variables" of _demografr_, we need to take care of the nesting:

```{r}
variable <- as.list(prior)[[2]]
variable
```

```{r}
as.list(variable)
```

### In _demografr_ then...

```{r}
sample_prior(T_split[10] ~ runif(10, 10000))
```

Which internally turns the prior expression into `runif(n = 10, min = 10, max = 10000)`.

## A list of all priors

```{r}
priors <- list(
  Ne          ~ runif(1000, 1000),
  geneflow    ~ runif(0, 1),
  T_split[10] ~ runif(10, 1000)
)
```

**The point of this is that this is _declarative_! It defines the priors, but doesn't sample any numbers!**

But, during each ABC replicate simulation, _demografr_ then internally performs the equivalent of this:

```{r}
lapply(priors, sample_prior) # iterate over the list of priors, sample from each
```

**But this is something the user never has to do or care about**, it is done automatically and internally when they call:

```{r, eval=FALSE}
data <- simulate_abc(model, <priors>, functions, observed, ...)
```

## Custom functions

The above also allows custom-defined prior distribution functions, not just built-in `runif`, `rnorm`, etc.

For instance, imagine this function simulating a loaded casino die:

```{r}
casino_d6 <- function(n = 1) {
  outcomes      <- c(1, 2, 3, 4, 5, 6) # six sides of a die
  probabilities <- c(1, 1, 1, 1, 1, 3) # rolling a 6 is 3x more likely!

  sample(outcomes, size = n, prob = probabilities, replace = TRUE)
}
```

```{r}
prior <- rolls[100] ~ casino_d6()

samples <- sample_prior(prior)
samples
```

```{r}
table(samples$value)
```