---
title: "vignette-02-split_times"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette-01-overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(abc)
library(dplyr)
library(future)
library(slendr)

devtools::load_all(".")
```

```{r, echo=FALSE}
rds_file <- system.file("extdata/vignette_01_splits.rds", package = "demografr")
```

```{r}
# nodes <- c("r1", "r2", "r3", "r4", "r5", "r6")
# plan(list(tweak(cluster, workers = nodes, homogeneous = FALSE),
#           tweak(multisession, workers = 50)))
plan(multicore, workers = 10)
```

Define a skeleton model to fit parameters for:

```{r}
p1 <- population("p1", time = 1, N = 1000)
p2 <- population("p2", time = 2000, N = 100, parent = p1)
p3 <- population("p3", time = 6000, N = 3000, parent = p2)

model <- compile_model(
  populations = list(p1, p2, p3),
  generation_time = 1,
  simulation_length = 10000, serialize = FALSE
)

# plot_model(model)
```

Simulate true summary statistics from this model. Later, we will use those to fit parameters of the model, pretending that we forgot the truth:

```{r}
ts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) %>% ts_mutate(1e-8)
samples <- ts_samples(ts) %>% split(., .$pop) %>% lapply(`[[`, "name")

observed_stats <- list(
  pi = ts_diversity(ts, sample_sets = samples) %>% mutate(stat = paste0("pi_", set)) %>% select(stat, value = diversity),
  divergence = ts_divergence(ts, sample_sets = samples) %>% mutate(stat = sprintf("d_%s_%s", x, y)) %>% select(stat, value = divergence)
)
```

Define prior distributions for model parameters:

```{r}
priors <- list(
  Ne_p1 ~ runif(10, 10000),
  Ne_p2 ~ runif(10, 10000),
  Ne_p3 ~ runif(10, 10000),
  Tsplit_p2_p3 ~ runif(3000, 8000),
  Tsplit_p1_p2 ~ runif(1, 5000)
)

plot_prior(priors)
```

Define set of R functions operating on a tree sequence which will be used to compute summary statistics during the ABC inference:

```{r}
# setup summary statistic functions
compute_pi <- function(ts) {
  samples <- ts_samples(ts) %>% split(., .$pop) %>% lapply(`[[`, "name")
  ts_diversity(ts, sample_sets = samples) %>%
    mutate(stat = paste0("pi_", set)) %>%
    dplyr::select(stat, value = diversity)
}

functions <- list(pi = compute_pi)
```

Generate simulation replicates for ABC analysis, drawing parameters of the model from the prior and computing summary statistics for each simulation:

```{r, eval=!file.exists(rds_file)}
mutation_rate <- 1e-8
sequence_length <- 10e6
recombination_rate <- 1e-8
Sys.time()
# get ABC iterations
data <- simulate_abc(
  model, priors,
  summary_funs = functions,
  observed_stats = observed_stats,
  iterations = 1000, mutation_rate = 1e-8
)
Sys.time()
```

```{r, echo=FALSE}
# saveRDS(data, rds_file)
data <- readRDS(rds_file)
```

```{r}
abc <- perform_abc(data, tolerance = 0.01, method = "neuralnet")
```

```{r}
summary(abc)
```

```{r}
hist(abc, breaks = 50, "N_p1")
plot(abc, param = "N_p1")
```

Plot posterior distributions of interest:

```{r}
plot_posterior(abc, alpha = 0.75)
```

Extract posterior data (or simulate from priors) as simple data frames:

```{r}
simulate_priors(priors, replicates = 100)
```

```{r}
extract_posterior(abc)
```
