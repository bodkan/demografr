#' Perform ABC on data generated by \code{simulate_abc}
#'
#' Runs a selected ABC method on simulated data using R package abc as
#' an inference engine.
#'
#' This function serves as a wrapper around the function \code{\link[abc]{abc}} from
#' the R package abc. All function arguments except to \code{data} are passed to the
#' \code{\link[abc]{abc}} function, appropriately unpacking the prior sample matrix,
#' and binding together matrices with observed statistics and simulated statistics
#' in the format required by the inference function.
#'
#' This function exists to avoid the need to manually track parameter matrices
#' and summary statistics as inputs to the \code{\link[abc]{abc}} function but acts
#' entirely transparently. A such, all implementation details can be found in the abc
#' vignette and the manpage which you can access by typing \code{?abc::abc}.
#'
#' @param data Simulated data set produced by \code{simulate_abc}
#' @param engine Which ABC engine to use? As of the current version of demografr, the
#'   valid choices are either "abc" or "ABC_mcmc".
#' @param ... Additional arguments passed on the the \code{abc} function from
#'   the abc package
#'
#' @export
run_abc <- function(data, engine, ...) {
  engine <- match.arg(engine, choices = c("abc", "ABC_mcmc"))
  args <- match.call()

  # and to the same for the observed statistics as well
  observed <- lapply(names(data$functions), function(stat) {
    # convert observed statistics to a matrix, either from a normal data frame
    # result (with each statistic named), or from a simple vector
    x <- data$observed[[stat]]

    if (is.data.frame(x)) {
      # find the column with the value of a statistic `stat`
      # TODO: the last column will be numeric
      # value_col <- sapply(names(x), function(i) is.numeric(x[[i]]))
      value_col <- ncol(x)
      values <- matrix(x[, value_col, drop = TRUE], nrow = 1)
      names <- x[, !value_col, drop = FALSE] %>%
        apply(MARGIN = 1, FUN = function(row) paste(c(stat, row), collapse = "_"))
    } else {
      values <- matrix(x, nrow = 1)
      names <- paste0(stat, "_", seq_along(x))
    }
    colnames(values) <- names
    values
  }) %>% do.call(cbind, .)

  if (engine == "abc") {
    if (!"tol" %in% names(args))
      stop("The `tol` argument must be provided to use the abc() inference engine.\n",
           "See `?abc::abc` for more details.", call. = FALSE)
    if (!"method" %in% names(args))
      stop("The `method` argument must be provided to use the abc() inference engine.\n",
           "See `?abc::abc` for more details.", call. = FALSE)
    result <- abc::abc(
      param = data$parameters,
      target = observed,
      sumstat = data$simulated,
      ...
    )
  } else if (engine == "ABC_mcmc") {
    stop("ABC_mcmc engine not yet supported", call. = FALSE)
  }

  # the result of the abc analysis is a standard object produced by the R package abc,
  # but additional annotation is added so that demografr's own functions can be used
  # for additional analyses and plotting...
  components <- list(
    model = data$model,
    priors = data$priors,
    parameters = data$parameters,
    functions = data$functions,
    simulated = data$simulated,
    observed = data$observed
  )

  attr(result, "components") <- components
  attr(result, "options") <- attr(data, "options")

  # ... which is why the result is annotated with another class
  class(result) <- c(paste0("demografr_abc.", engine), engine)

  result
}
