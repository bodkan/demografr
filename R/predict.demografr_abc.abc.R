#' Generate summary statistics from the inferred posterior distribution of parameters
#'
#' The function draws parameter values from the posterior distribution and then
#' internally runs the function \code{simulate_grid} to run simulations from
#' the sampled parameters and compute tree-sequence summary statistics
#'
#' @param abc ABC object generated by \code{perform_abc}
#' @param samples Number of draws from the posterior distribution to simulate
#' @param stat Which tree-sequence summary statistic to compute? If \code{NULL}, all summary
#'   statistics will be computed.
#' @param posterior Should 'unadj'usted or 'adj'usted parameters be sampled? Default
#'   (recommended) value is 'unadj'usted.
#' @param functions A named list of summary statistic tree-sequence functions to be
#'   applied to each simulated tree sequence. If \code{NULL} (the default), the same
#'   summary statistics will be computed as those that were used in the ABC inference
#'   itself. Otherwise, custom tree-sequence summary statistics can be provided.
#'
#' @return A data frame object with the results of posterior simulations, with values of
#'  each summary statistic stored in a list-column (i.e. the same format as used by
#'  the function \code{simulate_grid}, as the predictions are generated internally using
#'  this function)
#'
#' @export predict.demografr_abc.abc
#' @export
predict.demografr_abc.abc <- function(abc, samples, stat = NULL, posterior = c("adj", "unadj"),
                                      functions = NULL) {
  opts <- options(warn = 1)
  on.exit(options(opts))

  # extract the model function and other components and options used to run the
  # original ABC simulations
  components <- attr(abc, "components")
  opts <- attr(abc, "options")

  if (is.null(components) || is.null(opts))
    stop("The provided 'abc' object lacks demografr's metadata. Are you sure\n",
         "that you provided the correct input object?", call. = FALSE)

  all_stats <- names(components$functions)
  if (is.null(stat))
    stat <- all_stats
  if (!all(stat %in% all_stats))
    stop("Unknown statistic(s) '", paste(stat, collapse = ", "), "' specified", call. = FALSE)

  posterior <- match.arg(posterior)
  if (posterior == "adj")
    warning("Please note that sampling 'adjusted' parameters from the posterior\n",
            "can lead to invalid models (i.e. inconsistent orders of split times)", call. = FALSE)

  if (is.null(functions)) functions <- components$functions

  if (is.null(names(functions)) || any(names(functions) == ""))
    stop("All elements of the list of summary statistic functions must be named", call. = FALSE)

  posterior_params <- abc[[paste0(posterior, ".values")]]

  # sample given number of samples from the posterior distribution of all parameters,
  # with replacement, adjusting by weights
  samples <- sample(seq_len(nrow(posterior_params)), size = samples, replace = TRUE, prob = abc$weights)

  # parameters <- dplyr::as_tibble(abc$adj[samples, ])
  parameters <- dplyr::as_tibble(posterior_params[samples, ])

  # once we have sampled parameters from the posteriors, getting the summary statistics
  # is simply a matter of running simulations across a grid
  result <- simulate_grid(
    model = components$model,
    grid = parameters,
    functions = functions,
    replicates = 1,
    sequence_length = opts$sequence_length,
    recombination_rate = opts$recombination_rate,
    mutation_rate = opts$mutation_rate,
    packages = opts$packages,
    engine = opts$engine, model_args = opts$model_args, engine_args = opts$engine_args
  )

  attr(result, "components") <- components["observed"]

  result
}