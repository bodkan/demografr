#' Generate summary statistics from the inferred posterior distribution of parameters
#'
#' The function draws parameter values from the posterior distribution and then
#' internally runs the function \code{simulate_grid} to run simulations from
#' the sampled parameters and compute tree-sequence summary statistics
#'
#' @param object ABC object generated by \code{run_abc}
#' @param samples Number of draws from the posterior distribution to simulate
#' @param stat Which tree-sequence summary statistic to compute? If \code{NULL}, all summary
#'   statistics will be computed.
#' @param posterior Should 'unadj'usted or 'adj'usted parameters be sampled? Default
#'   (recommended) value is 'unadj'usted.
#' @param strict Should parameter combinations leading to invalid slendr models be treated as
#'   an error? Default is \code{TRUE}. If set to \code{FALSE}, invalid simulations will be
#'   simply dropped, with an informative message. This parameter is internally passed to the
#'   function \code{simulate_grid()} which performs the simulations across a sampled parameter
#'   matrix.
#' @param functions A named list of summary statistic tree-sequence functions to be
#'   applied to each simulated tree sequence. If \code{NULL} (the default), the same
#'   summary statistics will be computed as those that were used in the ABC inference
#'   itself. Otherwise, custom tree-sequence summary statistics can be provided.
#' @param ... A formal argument of the \code{predict} generic method (unused)
#'
#' @return A data frame object with the results of posterior simulations, with values of
#'  each summary statistic stored in a list-column (i.e. the same format as used by
#'  the function \code{simulate_grid}, as the predictions are generated internally using
#'  this function)
#'
#' @export predict.demografr_abc.abc
#' @export
predict.demografr_abc.abc <- function(object, samples, stat = NULL, posterior = c("adj", "unadj"),
                                      strict = FALSE, functions = NULL, ...) {
  opts <- options(warn = 1)
  on.exit(options(opts))

  # extract the model function and other components and options used to run the
  # original ABC simulations
  components <- attr(object, "components")
  opts <- attr(object, "options")

  if (is.null(components) || is.null(opts))
    stop("The provided 'abc' object lacks demografr's metadata. Are you sure\n",
         "that you provided the correct input object?", call. = FALSE)

  all_stats <- names(components$functions)
  if (is.null(stat))
    stat <- all_stats
  if (!all(stat %in% all_stats))
    stop("Unknown statistic(s) '", paste(stat, collapse = ", "), "' specified", call. = FALSE)

  posterior <- match.arg(posterior)
  if (posterior == "adj")
    warning("Please note that sampling adjusted parameters from the posterior\n",
            "can lead to invalid models (i.e. inconsistent orders of split times or\n",
            "nonsensical values of parameters in general). If you get an error, you\n",
            "can either sample unadjusted parameters  by setting `posterior = \"unadj\"`\n",
            "or instruct the prediction function to skip invalid models by setting\n",
            "`strict = FALSE`.", call. = FALSE)

  if (is.null(functions)) functions <- components$functions

  if (is.null(names(functions)) || any(names(functions) == ""))
    stop("All elements of the list of summary statistic functions must be named", call. = FALSE)

  posterior_params <- object[[paste0(posterior, ".values")]]

  # sample given number of samples from the posterior distribution of all parameters,
  # with replacement, adjusting by weights
  samples <- sample(seq_len(nrow(posterior_params)), size = samples, replace = TRUE, prob = object$weights)

  # parameters <- dplyr::as_tibble(abc$adj[samples, ])
  parameters <- dplyr::as_tibble(posterior_params[samples, ])

  # once we have sampled parameters from the posteriors, getting the summary statistics
  # is simply a matter of running simulations across a grid
  result <- simulate_grid(
    model = components$model,
    grid = parameters,
    functions = functions,
    replicates = 1,
    sequence_length = opts$sequence_length,
    recombination_rate = opts$recombination_rate,
    mutation_rate = opts$mutation_rate,
    packages = opts$packages,
    engine = opts$engine, model_args = opts$model_args, engine_args = opts$engine_args,
    strict = strict
  )

  attr(result, "components") <- components["observed"]

  result
}
