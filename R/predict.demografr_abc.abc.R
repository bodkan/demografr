#' Simulate given summary statistics from the inferred parameter model posteriors
#'
#' The function draws parameter values from the posterior distribution and then
#' internally runs the function \code{simulate_grid} to run simulations from
#' the sampled parameters and compute tree-sequence summary statistics
#'
#' @param object ABC object generated by \code{run_abc}
#' @param samples Number of draws from the posterior distribution to simulate
#' @param stat Which tree-sequence summary statistic to compute? If \code{NULL}, all summary
#'   statistics will be computed.
#' @param posterior Should 'unadj'usted or 'adj'usted parameters be sampled? Default
#'   (recommended) value is 'unadj'usted.
#' @param strict Should parameter combinations leading to invalid slendr models be treated as
#'   an error? Default is \code{TRUE}. If set to \code{FALSE}, invalid simulations will be
#'   simply dropped, with an informative message. This parameter is internally passed to the
#'   function \code{simulate_grid()} which performs the simulations across a sampled parameter
#'   matrix.
#' @param functions A named list of summary statistic tree-sequence functions to be
#'   applied to each simulated tree sequence. If \code{NULL} (the default), the same
#'   summary statistics will be computed as those that were used in the ABC inference
#'   itself. Otherwise, custom tree-sequence summary statistics can be provided.
#' @param packages A character vector with package names used by user-defined summary statistic
#'   functions. Only relevant when parallelization is set up using \code{future::plan()} to make
#'   sure that the parallelized tree-sequence summary statistic functions have all of their
#'   packages available.
#' @param globals If a summary statistic function depends on object(s) in the R session which
#'   would not be available in separate parallel simulation processes, the names of such object(s)
#'   can be specified here, and they will be passed to each such separate process.
#' @param ... A formal argument of the \code{predict} generic method (unused)
#'
#' @return A data frame object with the results of posterior simulations, with values of
#'  each summary statistic stored in a list-column (i.e. the same format as used by
#'  the function \code{simulate_grid}, as the predictions are generated internally using
#'
#' @examples
#' \dontrun{
#' # read statistics computed from posterior sample simulations
#' # the `pred` object was produced by the following call:
#' #    pred <- predict(abc, samples = 1000, posterior = "unadj")
#' # (where `abc` is the product of the `run_abc()` function)
#' pred <- readRDS(url(paste0(
#' "https://raw.githubusercontent.com/bodkan/demografr/",
#' "refs/heads/main/inst/examples/downstream_predX.rds"
#' )))
#'
#' # note the columns `diversity`, `divergence`, and `f4`
#' pred
#'
#' # extract_prediction() is a convenience function which unpacks the given
#' # summary statistic in a normal data frame column (here `diversity`)
#' extract_prediction(pred, "diversity")
#'
#' # we can also plot the posterior predictive distributions for all statistics
#' plot_prediction(stats, "diversity")
#' plot_prediction(stats, "divergence")
#' }
#'
#' @export predict.demografr_abc.abc
#' @export
predict.demografr_abc.abc <- function(object, samples, stat = NULL, posterior = c("adj", "unadj"),
                                      strict = FALSE, functions = NULL, packages = NULL, globals = NULL, ...) {
  opts <- options(warn = 1)
  on.exit(options(opts))

  if (missing(samples))
    stop("The number of samples to generate from the posterior must be specified", call. = FALSE)

  # extract the model function and other components and options used to run the
  # original ABC simulations
  components <- attr(object, "components")
  opts <- attr(object, "options")

  if (is.null(components) || is.null(opts))
    stop("The provided 'abc' object lacks demografr's metadata. Are you sure\n",
         "that you provided the correct input object?", call. = FALSE)

  all_stats <- names(components$functions)
  if (is.null(stat))
    stat <- all_stats
  if (!all(stat %in% all_stats))
    stop("Unknown statistic(s) '", paste(stat, collapse = ", "), "' specified", call. = FALSE)

  posterior <- match.arg(posterior)
  if (posterior == "adj")
    warning("Note that sampling adjusted parameters from the posterior\n",
            "can lead to invalid models (i.e. inconsistent orders of split times or\n",
            "nonsensical values of parameters in general). If you get an error, you\n",
            "can either sample unadjusted parameters by setting `posterior = \"unadj\"`\n",
            "or instruct the prediction function to skip invalid models by setting\n",
            "`strict = FALSE`.", call. = FALSE)

  if (is.null(functions)) functions <- components$functions

  if (is.null(names(functions)) || any(names(functions) == ""))
    stop("All elements of the list of summary statistic functions must be named", call. = FALSE)

  posterior_params <- object[[paste0(posterior, ".values")]]
  if (!is.matrix(posterior_params)) posterior_params <- as.matrix(posterior_params)

  # sample given number of samples from the posterior distribution of all parameters,
  # with replacement, adjusting by weights
  samples <- sample(seq_len(nrow(posterior_params)), size = samples, replace = TRUE, prob = object$weights)

  # parameters <- dplyr::as_tibble(abc$adj[samples, ])
  parameters <- dplyr::as_tibble(posterior_params[samples, ])

  # save this to a simple variable to avoid issues with a complex substitute-based
  # model name composed of multiple components
  model <- components$model

  # once we have sampled parameters from the posteriors, getting the summary statistics
  # is simply a matter of running simulations across a grid, in the same way a
  # user would do it directly in cases where they already had parameter values
  # to simulate from
  result <- simulate_grid(
    model = model,
    grid = parameters,
    functions = functions,
    replicates = 1,
    sequence_length = opts$sequence_length,
    recombination_rate = opts$recombination_rate,
    mutation_rate = opts$mutation_rate,
    engine = opts$engine, model_args = opts$model_args, engine_args = opts$engine_args,
    strict = strict,
    packages = c(opts$packages, packages),
    globals = unique(c(opts$globals, globals))
  )
  # replace the replicate number from simulate_grid by actual numbers of each
  # posterior draw for easier downstream analysis
  result$rep <- 1:nrow(result)

  attr(result, "components") <- components[c("observed", "model_name")]

  result
}
