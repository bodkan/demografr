run_simulation <- function(model, Ne_samples, sequence_length, recombination_rate) {
  # replace Ne values in the model object
  for (Ne in Ne_samples) {
    model$splits[model$splits$pop == Ne$variable, "N"] <- as.integer(Ne$value)
  }

  ts <- slendr::msprime(model, sequence_length = sequence_length, recombination_rate = recombination_rate)
  ts
}

run_iteration <- function(it, priors, functions, mutation_rate, sequence_length, recombination_rate) {
  setup_env(quiet = TRUE)

  Ne_samples <- lapply(priors, sample_prior)

  ts <- run_simulation(model, Ne_samples, sequence_length, recombination_rate)
  if (mutation_rate != 0)
    ts <- ts_mutate(ts, mutation_rate = mutation_rate)

  simulated_stats <- lapply(functions, function(f) f(ts))

  Ne_values <- matrix(sapply(Ne_samples, `[[`, "value"), nrow = 1)
  colnames(Ne_values) <- as.character(lapply(Ne_samples, `[[`, "variable"))

  list(
    parameters = Ne_values,
    simulated_stats = simulated_stats
  )
}

#' Simulate data for ABC inference using specified priors
#' 
#' @param model A compiled slendr model object
#' @param priors A list of prior distributions to use for sampling of model parameters
#' @param summary_funs A named list of summary statistic functions to apply on simulated
#'   tree sequences
#' @param observed A named list of observed summary statistics
#'
#' @export
simulate_abc <- function(
  model, priors, summary_funs, observed_stats,
  iterations = 1, epochs = 1,
  mutation_rate = 0, sequence_length = 10e6, recombination_rate = 1e-8
) {
  if (length(setdiff(names(summary_funs), names(observed_stats))))
    stop("List of summary functions and observed statistics must have the same names",
         call. = FALSE)

  # results <- future.apply::future_lapply(
  results <- parallel::mclapply(
  # results <- lapply(
    X = seq_len(iterations),
    FUN = run_iteration,
    priors = priors,
    functions = functions,
    mutation_rate = mutation_rate,
    sequence_length = sequence_length,
    recombination_rate = recombination_rate,
    mc.cores = 10
    # future.seed = TRUE
  )

  parameters <- lapply(results, `[[`, "parameters") %>% do.call(rbind, .) %>% as.matrix
  simulated_stats <- lapply(results, `[[`, "simulated_stats")

  list(
    parameters = parameters,
    simulated = simulated_stats,
    observed = observed_stats,
    statistics = names(summary_funs)
  )
}

#' Perform ABC inference on the data generated by \code{simulate_abc}
#' 
#' @param tolerance Proportion of samples to accept in the neighborhood of observed values
#' @param method ABC algorithm to use for inference. Options are "rejection", "loclinear",
#'   "neuralnet", and "ridge". For details, see the \code{abc} function from the package abc.
#'
#' @export 
perform_abc <- function(data, tolerance, method, ...) {
  parameters <- data$parameters

  observed <- lapply(data$statistics, function(stat) {
    df <- data$observed[[stat]]
    values <- matrix(df[, 2, drop = TRUE], nrow = 1)
    colnames(values) <- df[, 1, drop = TRUE]
    values
  }) %>% do.call(cbind, .)

  simulated <- lapply(data$statistics, function(stat) do.call(
    rbind, lapply(data$simulated, function(it) {
      df <- it[[stat]]
      values <- matrix(df[, 2, drop = TRUE], nrow = 1)
      colnames(values) <- df[, 1, drop = TRUE]
      values
    }))
  ) %>% do.call(cbind, .)

  result <- abc(
    param = parameters,
    target = observed,
    sumstat = simulated,
    tol = tolerance,
    method = method,
    ...
  )

  attr(result, "parameters") <- data$parameters
  class(result) <- c("demografr_abc", "abc")

  result
}

#' Extract slendr model constructed from the ABC posterior distribution
#'
#' @param abc ABC object generated by \code{perform_abc}
#' @param summary Which summary statistic of the posterior distribution to use? Options are
#'   "mode" (i.e. MAP estimates), "mean", or "median".
#'
#' @export
extract_model <- function(abc, summary = c("mode", "mean", "median")) {
  summary <- match.arg(summary) %>% tools::toTitleCase()

  summary_df <- quiet(summary(abc))[sprintf("Weighted %s:", summary), ]
  model <- attr(abc, "model")

  # replace Ne values in the scaffold model object with their ABC estimates
  for (param in names(summary_df)) {
    if (grepl("^N_", param)) {
      pop <- gsub("N_", "", param)
      model$splits[model$splits$pop == pop, "N"] <- round(summary_df[param])
    }
  }

  model
}
