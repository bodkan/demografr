#' Extract names of individuals in a tree sequence
#'
#' @param ts Tree-sequence object simulated by a slendr back-end engine
#' @param split Should sample names be split by population? Default is \code{FALSE}
#'
#' @return A vector of character sample names. If \code{split} is \code{TRUE},
#'   a list of such vectors is returned, one element of the list per population.
#'
#' @export
sample_names <- function(ts, split = FALSE) {
  if (split)
    slendr::ts_samples(ts) %>% split(., .$pop) %>% lapply(`[[`, "name")
  else
    slendr::ts_samples(ts)$name
}

#' Print a brief summary of a set of demografr simulations
#'
#' @param x An object of the class \code{demografr_sims}, generated by \code{simulate_abc}
#'
#' @return Used exclusively for printing
#'
#' @export
#' @keywords internal
print.demografr_sims <- function(x, ...) {

  n_iterations <- nrow(x$parameters)
  cat("Number of simulation replicates:", n_iterations, "\n\n")

  parameters <- colnames(x$parameters) #%>% paste(collapse = ", ")
  types <- sapply(parameters, function(p) strsplit(p, "_")[[1]][1])
  cat("Model parameters to be estimated:\n")
  for (set in split(parameters, types)) {
    cat("   ", paste(set, collapse = ", "), "\n")
  }

  cat("\n")

  summaries <- names(x$functions) %>% paste(collapse = ", ")
  cat("Summary statistics used:\n    ")
  cat(summaries, "\n")

  cat("\n")

  cat("Individual components of this object can be accessed as:\n")
  cat("    <object>$parameters -- parameter matrix\n")
  cat("    <object>$observed   -- observed summary statistics\n")
  cat("    <object>$functions  -- summary functions\n")
  cat("    <object>$priors     -- prior expressions\n")
}

#' @importFrom slendr init_env
#' @export
slendr::init_env

# Check that the function argument is really provided by the user
check_arg <- function(x) {
  tryCatch({get(deparse(substitute(x))); TRUE}, error = function(e) FALSE) ||
  tryCatch({!is.null(x); TRUE}, error = function(e) FALSE)
}

# a function to silence the unnecessary summary() output on abc objects
# https://stackoverflow.com/a/54136863
quiet <- function(x) {
  sink(tempfile())
  on.exit(sink())
  invisible(force(x))
}

# Extract prior variable names as a character vector
prior_variables <- function(priors) {
  sapply(priors, function(p) as.character(as.list(p)[[2]]))
}
